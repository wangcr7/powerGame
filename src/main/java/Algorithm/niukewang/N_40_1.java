package Algorithm.niukewang;

/**
 * 一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。
 */
//num1,num2分别为长度为1的数组。传出参数
//将num1[0],num2[0]设置为返回结果

/**
 * 我们首先仍然从前向后依次异或数组中的数字，那么得到的结果是两个只出现一次的数字的异或结果，其他成对出现的数字被抵消了。
 * 由于这两个数字不同，所以异或结果肯定不为0，也就是这个异或结果一定至少有一位是1，我们在结果中找到第一个为1的位的位置，记为第n位。
 * 接下来，以第n位是不是1为标准，将数组分为两个子数组，第一个数组中第n位都是1，第二个数组中第n位都是0。
 * 这样，便实现了我们的目标。最后，两个子数组分别异或则可以找到只出现一次的数字。
 */

/**
 * 以{2,4,3,6,3,2,5,5}为例：
 *
 *   我们依次对数组中的每个数字做异或运行之后，得到的结果用二进制表示是0010。
 * 异或得到结果中的倒数第二位是1，于是我们根据数字的倒数第二位是不是1分为两个子数组。
 * 第一个子数组{2,3,6,3,2}中所有数字的倒数第二位都是1，而第二个子数组{4,5,5}中所有数字的倒数第二位都是0。
 * 接下来只要分别两个子数组求异或，就能找到第一个子数组中只出现一次的数字是6，而第二个子数组中只出现一次的数字是4
 */
public class N_40_1 {


    public void FindNumsAppearOnce(int [] array,int num1[] , int num2[]) {
        /*
        思路：数组中的元素先依次异或，相同为0，则得到的是两个只出现一次的数的异或结果
        对于得到的异或结果，找到其第一个为1的位
        该位为1，说明两个只出现一次的数该位不同，所以按照该位是0还是1将数组分成两部分
        这样，出现两次的数字都会分到同一个部分，而两个只出现一次的数正好被分开，再各自异或可得结果
        */
        if(array==null || array.length<2)
            return ;
        int res=0;
        for(int num : array) //数组中的元素先依次异或，相同为0，则得到的是两个只出现一次的数的异或结果
            res ^= num;

        int index=0; //找到其第一个为1的位
        for(;index < 32; index++){
            if(((res >> index) & 1)==1)
                break;
        }

        num1[0] = 0;
        num2[0] = 0;
        for(int num : array){ //按照该位是0还是1将数组分成两部分,分别异或
            if(((num >> index)&1) == 1)
                num1[0] ^= num;
            else
                num2[0] ^= num;
        }
    }

    public static void main(String[] args) {

        int [] array = new int[]{2,4,3,6,3,2,5,5};

        // 2 3 2 5

        int bitResult = 0;

        for (int i = 0; i < array.length; i++) {
            bitResult = bitResult ^ array[i];
        }

        System.out.println(bitResult);
    }
}
